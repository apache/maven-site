h1. Maven 2.1 -- Jason van Zyl

h2. Architectural Goals

h3. Backward Compatibility
* Plugins using the 2.0.x Plugin API must run in 2.1.x (* with the exception of anything maven-artifact related)
* Reports using the 2.0.x Report API must run in 2.1.x (* with the exception of anything maven-artifat related)

h3. POM changes

There are many changes that users have requested in the POM, in addition to wholesale formatting changes. Acommodating these requests is a little tricky
because we need to support different versions simultaneously so that if projecta A builds with 2.0.x, project B can consume the project A POM using 2.1.x.
We just need some way to easy support multiple versions and support mediation between the different versions.

* Tags 
* dependency excludes && symmetry
* terse attribute based format for the POM
* properties on dependencies
* Specification Dependencies
* Schematron/RelaxNG descriptor for each plugin -- Bryon Jacob proposed a flexible model but XSD is hard to fight here

h3. Embedding

Full embedding of the Maven core is a major feature of the 2.1.x line. The embedder was created primarily for IDE integration and is now being consumed by m2eclipse, Mevenide and IDEA,
but the embedder is also used by the Maven CLI to ensure parity between IDEs and the CLI as much as possible. To understand how the embedder work you can refer to
the [Maven Embedder documentation|http://maven.apache.org/guides/mini/guide-embedding-m2.html].

h3. Custom Components

As discussed in [Substituting of Custom Components|http://docs.codehaus.org/display/MAVEN/Substitution+of+Custom+Maven+Components] we now have two ways
to insert new components into the system.

* Using a directory and specifying it in the Classworlds configuration. Tycho simply has a special set of components that load first before the standard maven components and they override 
  the standard Maven components. Here's the example based on what Tycho is currently doing which allows custom components to be used.
  
{code}
main is org.apache.maven.cli.MavenCli from plexus.core                                                                                                                     
                                                                                                                                                                           
set maven.home default ${user.home}/m2                                                                                                                                     
                                                                                                                                                                           
[plexus.core]                                                                                                                                                              
load ${maven.home}/tycho/*.jar                                                                                                                                             
load ${maven.home}/lib/*.jar 
{code}

* The embedder has the ContainerCustomizer which allow you to inject new component descriptors. This is used in the IDE integration (m2ecipse, Netbeans) for adding
  custom artifact resolvers.

But what we ultimately need for Tycho is a way to dynamically pull in a set of components based on the packaging of a project. In our case with Tycho the packaging is
maven-osgi-bundle and that should kick in the set of components that do builds for OSGi bundles. We also have another use case in Tycho where we are building OSGi bundles
without a POM and actually using a manifest. In this case we need to somehow detect the manifest and then have the custom set of components kick in. In the case of Tycho
we need a different project builder, and artifact resolver.

h3. Mercury

Mercury is a replacement for the current Maven Artifact subsystem, and a complete replacement for the HTTP and DAV portions of the existing transport.

The primary reasons for replacing the code are that it is unmaintainable and nearly impossible to navigate, it uses completely non-standard structures and libraries for
version calculations, the API is too hard for people to use, and it is not given to users to consume as a single componment to use. Users are forced to know how several
complicated components interact in order to implement a mechanism of retrieving artifacts from a repository. The entire mechanism needs to be replaced with something
that can be maintained and is reliable. 

Mercury started as some fixes to Maven Artifact to first help with embeddability and error reporting for IDE integration. This was a direct result of all IDE integrators
having to reimplement the current artifact resolver to provide decent feedback to users when errors occured. The artifact subsystem would just die and leave the IDE in
an unusable state. Milos was the first to implement his own artifact resolver, and Eugene soon had to do the same in m2eclipse. Oleg and I were also trying to use the
current artifact mechanism in an embedded mode for some Eclipse plugins and this also proved to be quite painful. After the first attempt of removing the fail-fast
behavior, Oleg and I decided to make a break from the old codebase and attempt to create Mercury with the following goals in mind:

* Find the best people in the world to help create an awesome HTTP and DAV implementation. We did this by talking to Greg, Jan, and Jesse who are the Jetty folks
  and there just isn't anyone who knows HTTP better. Greg and Jan are awesome, and Jesse is Maven committer so we have some deep understanding of the issues involved. So
  what Oleg and I wanted to see was: 
** Easy SSL support where mucky with certificates in the default install is not required.
** Connection pooling 
** Connection parallelization
** Built in DAV client support for deployment
** Atomic retrieval: we make sure absolutely everything is been safely transported to disk before we place it in the local Maven repository
** Atomic deployment: in this case we could only support this using a special filter Greg created which blocks requests for any artifacts being deploy in the current 
   set until the entire set land safely to disk. So it becomes impossible to ask for an artifact that refers to something else in the set before it is actually available. 

* Find the best solution possible solution for dealing with version calculations, in particular ranges. For this we called on Daniel Le Berre and ask for some help in
  integrating his SAT4J library. We learned about the SAT4J library from the P2 project over at Eclipse.org at the last EclipseCon. SAT4J was deemed the best way forward
  by the P2 team in providing the most reliable, and most workable solution for doing version calculation. SAT4J provides ways to plug-in strategies to deal with our 
  scopes, conflict resolution strategies and it is deadly fast. We felt we are in good company as we can call on Daniel and the P2 team and collaborate when difficult
  problems arise. 
  
* Find the best people to help with with security. This might an SSL-based solution to secure the channel where the source is known to be safe, a PGP-based solution where
  the contents must be secured assuming a hostile channel, or a combination of the two. To that end I have contacted the folks at the Legion of the Bouncy Castle and asked
  them to provide us the expertise to implement a safe and correct solution. I have not persued any help on the SSL.
  
So in the end I believe it would be detrimental to use the Maven Artifact code in the 2.1.x tree and the change needs to be made to use Mercury before the first alpha ships. Oleg
and I started this work, and Oleg has subsequently worked tirelessly on Mercury along with a great deal of help from Greg, Jan and Jesse. I think Oleg understands the requirements
as he's seen Maven in action in one of the largest development environments in the world and watched how Maven can fail spectacularly. 
  
h3. Plugin API
* Symmetric output expressions
* Java5 Mojo annotations (Yoav Landman has this working already)
* Clean separation of plugins from reports. It's not good that those are the same thing in the Maven internals.
** Not using concrete XML classes in the Plugin API (Xpp3Dom)

h3. Core Refactorings
* Project Builder
** Maven shared model work: a new way of reading in the models for Maven that is not format dependent in any way i.e. XML, text, YAML, scripts, whatever.
** Pluggable model readers: this could leverage different implementations provided by the shared model work, but we still need a way to detect the type and version
   of the model that we want to consume
** A new terse format that uses attributes
** Automatic parent versioning
** New interpolation component (plexus-interpolation)
** Dynamic build sections ([MNG-3530|http://jira.codehaus.org/browse/MNG-3530])
** Mixin support -- allowing a paramterizable template which can be imported with one line.

* Remove the use of separate plugin repositories. We only need to pull resources from one repository. We started doing this but I've had a couple
   clients that want to separate the tools they use from the code they are developing/building.
* Decouple script-based Plugins from the core -- we are a large part of the way here I need to summarize what was done.
* Remove Settings from the core and make it a user facing configuration (This is primarily done -- jason)
* Have one configuration model for request
* Have one configuration model for session: session takes the request in the constructor and delegates
* Domain logging
* Plugin Manager
**  Removal of the Plugin Registry (done) -- we moved in a direction where people lock down their versions and we've helped by putting default versions
    in the parent POM.
**  Load Plugin dependencies into a separate ClassRealm (done)
**  Plugin Execution Environment: Ability to run any version of a plugin where an environment is created which contains all the
    requirements for a particular version of the Plugin API

* Lifecycle Executor 
**  Queryable Lifecycle
*** The most important change in the embedding environment. You can actually query Maven for the complete execution before it happens. We must know the entire
    model of execution before we execute.
* Custom profile activators -- we don't have a lot of users except the C-based builds so it might be worth while getting rid of it.

h3. Java 5

Java5 annotations for plugins: we have two implementations that have now been merged in plexus-cdc. QDOX 1.7 has now been released so we may want to check the 
source level gleaning again. Jason Dillon has created a working class processing model. We need to deal with Plexus components and Maven plugins.
   
h3. Integration and promotion of scriptable plugins
       
h3. Toolchains
* Milos has implemented this and Shane had some feedback so this needs to be linked together

h3. Reporting
* Report Execution Environment: Ability to run any version of a report where an environment is created which contains all the requirements for a particular version of the Report API.
* Decouple the reporting core. We need to get Doxia out of the core. Anything it needs to run should be isolated.
