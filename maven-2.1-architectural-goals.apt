h1. Maven 2.1 

h2. Architectural Goals

h3. POM changes
* tags/categories
* dependency excludes && symmetry
* terse attribute based format for the POM
* properties on dependencies
* Specification Dependencies
* Schematron/RelaxNG descriptor for each plugin -- Bryon Jacob proposed a flexible model but XSD is hard to fight here
* Mixin support -- allowing a paramterizable template which can be imported with one line.

h3. Embedding

h3. Custom Components

As discussed in [Substituting of Custom Components|http://docs.codehaus.org/display/MAVEN/Substitution+of+Custom+Maven+Components] we now have two ways
to insert new components into the system.

* Using a directory and specifying it in the Classworlds configuration. Tycho simply has a special set of components that load first before the standard maven components and they override 
  the standard Maven components. Here's the example based on what Tycho is currently doing which allows custom components to be used.
  
{code}
main is org.apache.maven.cli.MavenCli from plexus.core                                                                                                                     
                                                                                                                                                                           
set maven.home default ${user.home}/m2                                                                                                                                     
                                                                                                                                                                           
[plexus.core]                                                                                                                                                              
load ${maven.home}/tycho/*.jar                                                                                                                                             
load ${maven.home}/lib/*.jar 
{code}

* The embedder has the ContainerCustomizer which allow you to inject new component descriptors. This is used in the IDE integration (m2ecipse, Netbeans) for adding
  custom artifact resolvers.

But what we ultimately need for Tycho is a way to dynamically pull in a set of components based on the packaging of a project. In our case with Tycho the packaging is
maven-osgi-bundle and that should kick in the set of components that do builds for OSGi bundles. We also have another use case in Tycho where we are building OSGi bundles
without a POM and actually using a manifest. In this case we need to somehow detect the manifest and then have the custom set of components kick in.

h3. Mercury
* Sustained connections for transfers (releasing and deploying)
* Artifact Resolution
* Graph-based artifact resolution
* Decouple from Maven's core
* Binary graph that is pre-resolved for a POM
* Conflict resolution is handled by SAT
* PGP support

h3. Model Changes
*  Tags and categorization in the POM
*  Specification dependencies
*  Dependency extensions
  *   Exclude all

h3. Plugin API
* Symmetric output expressions
* Java5 Mojo annotations (Yoav Landman has this working already)
* Clean separation of plugins from reports. It's not good that those are the same thing in the Maven internals.

h3. Core Refactorings
* Project Builder
** Maven shared model work
** Pluggable model readers
** A new terse format that uses attributes
** Allow mixin capabilities using an import directive
** Automatic parent versioning
** New interpolation component (plexus-interpolation)
** Dynamic build sections ([MNG-3530|http://jira.codehaus.org/browse/MNG-3530])
** Not using concrete XML classes in the Plugin API (Xpp3Dom)
* Remove the use of separate plugin repositories. We only need to pull resources from one repository. We started doing this but I've had a couple
   clients that want to separate the tools they use from the code they are developing/building.
* Decouple script-based Plugins from the core -- we are a large part of the way here I need to summarize what was done.
* Remove Settings from the core and make it a user facing configuration (This is primarily done -- jason)
* Have one configuration model for request
* Have one configuration model for session: session takes the request in the constructor and delegates
* Domain logging
* Plugin Manager
**  Removal of the Plugin Registry (done) -- we moved in a direction where people lock down their versions and we've helped by putting default versions
    in the parent POM.
**  Load Plugin dependencies into a separate ClassRealm (done)
**  Plugin Execution Environment: Ability to run any version of a plugin where an environment is created which contains all the
    requirements for a particular version of the Plugin API

* Lifecycle Executor 
**  Queryable Lifecycle
*** The most important change in the embedding environment. You can actually query Maven for the complete execution before it happens. We must know the entire
    model of execution before we execute.
* Custom profile activators -- we don't have a lot of users except the C-based builds so it might be worth while getting rid of it.

h3. Java 5

Java5 annotations for plugins: we have two implementations that have now been merged in plexus-cdc. QDOX 1.7 has now been released so we may want to check the 
source level gleaning again. Jason Dillon has created a working class processing model. We need to deal with Plexus components and Maven plugins.
   
h3. Integration and promotion of scriptable plugins

h3. Backward compatibility
*  Provide layer of adapters for plugin backward compatibility, to avoid immediate necessity to recode entire suite of plugins and reports for 2.1 compat.
  *  Integrity checking
    *  Don't allow builds where versions come from non-project sources
       like local settings and CLI parameters
    *  JC: Don't allow builds where versions come from profiles that
       have to be activated manually
       
h3. Toolchains
* Milos has implemented this and Shane had some feedback so this needs to be linked together

h3. Reporting
* Report Execution Environment: Ability to run any version of a report where an environment is created which contains all the requirements for a particular version of the Report API.
* Decouple the reporting core. We need to get Doxia out of the core. Anything it needs to run should be isolated.
