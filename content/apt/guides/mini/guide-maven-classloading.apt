 ------
 Guide to Maven Classloading
 ------
 Jason van Zyl
 Anders Kristian Andersen
 ------
 2008-12-10
 ------
 
~~ Licensed to the Apache Software Foundation (ASF) under one
~~ or more contributor license agreements.  See the NOTICE file
~~ distributed with this work for additional information
~~ regarding copyright ownership.  The ASF licenses this file
~~ to you under the Apache License, Version 2.0 (the
~~ "License"); you may not use this file except in compliance
~~ with the License.  You may obtain a copy of the License at
~~
~~   http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing,
~~ software distributed under the License is distributed on an
~~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
~~ KIND, either express or implied.  See the License for the
~~ specific language governing permissions and limitations
~~ under the License.

~~ NOTE: For help with the syntax of this file, see:
~~ http://maven.apache.org/doxia/references/apt-format.html

Guide to Maven Classloading

 This is a description of the classloader hierarchy in Maven.

%{toc|section=1|fromDepth=2}

* Overview

 Maven uses the {{{https://codehaus-plexus.github.io/plexus-classworlds/}Plexus Classworlds}} classloading framework with which we
 create our classloader graph. If you look in your <<<$\{maven.home\}/boot>>> directory you will see a single JAR
 which is the Classworlds JAR we use to boot the classloader graph. The Classworlds JAR is the only element of
 the Java <<<CLASSPATH>>> and Classworlds then builds the other classloaders or realms in Classworlds terminology.
 
 Each realm exposes
 
 [[1]] optionally some classes imported from 0..n other classloaders
 
 [[2]] optionally some classes from a directory or JAR
 
 [[3]] one parent classloader
 
 []
 
 The search order is always as given above.

* {Platform Classloader}

 This is the classloader exposing all JRE classes.

* {System Classloader}
 
 An Ant script like this will show the contents of the system/bootstrap classloader:
 
+---+
    <target name="info">
      <echo>java.class.path=${java.class.path}</echo>
    </target>
+---+

 It imports the platform classloader.

* {Core Classloader}
 
 The second classloader down the graph contains the core requirements of Maven. <<It is only used by Maven internally but not by Plugins>>. 
 The core classloader has the libraries in <<<$\{maven.home\}/lib>>>. In general these are just Maven libraries, e.g. instances of
 <<<{{{/ref/current/apidocs/org/apache/maven/project/MavenProject.html}MavenProject}}>>>
 belong to this classloader.
 
 You can add elements to this classloader by {{{/ref/current/maven-model/maven.html#class_extension}extensions}}. 
 These are loaded into the same place as <<<$\{maven.home\}/lib>>> and hence are available 
 to the Maven core and all plugins for the current project (through the API classloader).
 More information available in {{{./guide-using-extensions.html}Core Extension}}.

* {API Classloader}

 This exposes a filtered view of the Core Classloader by only exposing the exported packages from all Core Extensions.
 The main API is listed in {{{https://maven.apache.org/ref/3-LATEST/maven-core/core-extensions.html}Maven Core Extensions Reference}}.
 
 This has been introduced with Maven 3.3.1 ({{{https://issues.apache.org/jira/browse/MNG-5771}MNG-5771}}).

* {Build Extension Classloaders}

[../../buildExtensionClassRealm.svg] Build Extension Class Realm

 For every plugin which is marked with <<<\<extensions\>true\</extensions\>>>> or a build extension listed in the according section of the POM there is
 a dedicated classloader. Those are isolated (i.e. one build extension does not have access to other build extensions).
 It imports everything from API classloader.
 All JSR 330 or Plexus components declared in the underlying JAR are registered as components in the global Plexus container
 while creating the classloader.
 In addition all component references in the plugin descriptor are properly wired from the underlying Plexus container.
 Build extensions have limited effect as they are loaded late.

* {Project Classloaders}

 There is one project classloader per Maven project (identified through its GAV).
 This one imports the API Classloader. In addition it exposes all classes from all Build Extension Classloaders which are bound to the current project.
 This is only released with the container.
 During the build outside Mojo executions, the thread's context classloader is set to the project classloader.

* {Plugin Classloaders}

[../../pluginClassRealm.svg] Plugin Class Realm

 Each plugin (which is not marked as build extension) has its own classloader that imports the Project classloader. 
 
 Plugins marked with <<<\<extensions\>true\</extensions\>>>> leverage the Build Extension classloader instead of the Plugin classloader.

 Users can add dependencies to this classloader by adding dependencies 
 to a plugin in the <<<{{{/ref/current/maven-model/maven.html#class_plugin}plugins/plugin}}>>>
 section of their project <<<pom.xml>>>.
 Here is a sample of adding <<<ant-nodeps>>> to the plugin classloader of the Antrun Plugin and hereby enabling the use
 of additional/optional Ant tasks:
 
+---+
            <plugin>
              <groupId>org.apache.maven.plugins</groupId>
              <artifactId>maven-antrun-plugin</artifactId>
              <version>1.3</version>
              <dependencies>
                <dependency>
                  <groupId>org.apache.ant</groupId>
                  <artifactId>ant-nodeps</artifactId>
                  <version>1.7.1</version>
                </dependency>
              </dependencies>
              ...
            </plugin>
+---+
 
 Plugins can inspect their effective runtime class path via the expressions <<<$\{plugin.artifacts\}>>> or
 <<<$\{plugin.artifactMap\}>>> to have a list or map, respectively, of resolved artifacts injected from the
 <<<{{{/ref/current/maven-plugin-api/apidocs/org/apache/maven/plugin/descriptor/PluginDescriptor.html}PluginDescriptor}}>>>.

 Please note that the plugin classloader does neither contain the
 {{{/ref/current/maven-model/maven.html#class_dependency}dependencies}}
 of the current project nor its build output. Instead, plugins can query the project's compile, runtime and test class path from the 
 <<<{{{/ref/current/apidocs/org/apache/maven/project/MavenProject.html}MavenProject}}>>>
 in combination with the mojo annotation <<<requiresDependencyResolution>>> from the
 {{{/developers/mojo-api-specification.html}Mojo API Specification}}. For instance, flagging a
 mojo with <<<@requiresDependencyResolution runtime>>> enables it to query the runtime class path of the current project
 from which it could create further classloaders.

 When a build plugin is executed, the thread's context classloader is set to the plugin classloader.


* {Custom Classloaders}
 
 Plugins are free to create further classloaders on their discretion. For example, a plugin might want to create a
 classloader that combines the plugin class path and the project class path.
 
 It is important to understand that the plugin classloader cannot load classes from any of those custom classloaders.
 Some factory patterns require that. Here you must add the classes to the plugin classloader as shown before.
